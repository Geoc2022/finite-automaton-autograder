<head>
  <style>
    body {
      margin: 0;
      background-color: #eceff4;
    }
  </style>
  <script src="//cdn.jsdelivr.net/npm/force-graph"></script>
  <script type="module">
    import unicodeit from "https://cdn.jsdelivr.net/npm/unicodeit/+esm";
    window.unicodeit = unicodeit;
  </script>
</head>

<style>
  /* Based on quiver */
  :root {
    --ui-black: #2e3440;
    --ui-white: #eceff4;
    --ui-border: #4c566a;
  }

  .global-panel {
    position: fixed;
    left: 50%;
    bottom: 0;
    transform: translateX(-50%);
    height: 46px;
    padding: 4px 12px;
    z-index: 101;
    background: var(--ui-black);
    border-radius: 8px 8px 0 0;
    text-align: center;
    font-family: sans-serif;
    font-size: 14px;
    color: var(--ui-border);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
  }

  .panel-button {
    display: inline-block;
    background: transparent;
    border: 1px solid var(--ui-border);
    border-radius: 6px;
    color: var(--ui-white);
    padding: 6px 16px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.2s ease;
  }

  .panel-button:hover {
    background: #3b4252;
  }

  .panel-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .panel-button:disabled:hover {
    background: transparent;
  }

  .port {
    position: fixed;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
    z-index: 100;
    padding: 20px 24px;
    padding-bottom: calc(46px + 8px);
    overflow-y: auto;
    background: hsla(0, 0%, 10%, 0.8);
    backdrop-filter: blur(4px);
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  }

  .port-content {
    background: var(--ui-black);
    color: var(--ui-white);
    border: 1px solid var(--ui-border);
    border-radius: 8px;
    padding: 16px;
    max-width: 90%;
    width: 700px;
    font-family: monospace;
    white-space: pre-wrap;
    overflow-x: auto;
  }

  .port-close {
    margin-top: 16px;
    background: transparent;
    border: 1px solid var(--ui-border);
    color: var(--ui-white);
    border-radius: 6px;
    padding: 6px 12px;
    cursor: pointer;
  }

  .toolbar {
    position: fixed;
    height: 60px;
    left: 50%;
    top: 16px;
    transform: translateX(-50%);
    z-index: 90;
    background: #2e344000;
    border-radius: 8px;
    color: var(--ui-border);
    white-space: nowrap;
    transition: opacity .3s;

    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8 20px;
    font-family: sans-serif;
    line-height: 1.4;
    font-size: 14px;
  }

  .toolbar.hidden {
    opacity: 0;
    pointer-events: none;
  }
</style>

<!-- Panel -->
<div class="global-panel">
  <button class="panel-button" id="undoBtn">Undo</button>
  <button class="panel-button" id="redoBtn">Redo</button>
  <div style="border-left: 1px solid var(--ui-border); height: 24px; margin: 0 6px;"></div>
  Export:
  <button class="panel-button" id="urlBtn">URL</button>
  <button class="panel-button" id="jsonBtn">JSON</button>
  <button class="panel-button" id="latexBtn">LaTeX</button>
</div>

<!-- Overlay -->
<div class="port" id="overlayPort">
  <div class="port-content" id="portContent"></div>
  <button class="port-close" id="closeOverlay">Close</button>
</div>

<body>
  <div id="instructionsToolbar" class="toolbar">
    <div style="text-align: center;">
      <b>New node:</b> click canvas | <b>New link:</b> right-click source and target node
      <br>
      <b>Rename</b> click node or link | <b>Remove</b> shift-click node or link
      <br>
      <b>Select</b> right-click, use 'a' to toggle accepting or 's' to toggle start
    </div>
  </div>
  <div id="graph"></div>
</body>

<script>
  function encodeDFAForURL(nodes, links) {
    const exportData = {
      nodes: nodes.map(n => ({
        name: n.name,
        group: n.group ?? "normal"
      })),
      links: links.map(l => ({
        source: typeof l.source === "object" ? l.source.name : l.source,
        target: typeof l.target === "object" ? l.target.name : l.target,
        label: l.label ?? "a"
      }))
    };

    const json = JSON.stringify(exportData);
    const encoded = btoa(json).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    return encoded;
  }

  function decodeDFAFromURL(encoded) {
    try {
      const json = atob(encoded.replace(/-/g, "+").replace(/_/g, "/"));
      return JSON.parse(json);
    } catch (e) {
      console.error("Invalid DFA data in URL", e);
      return null;
    }
  }

  function exportToJson(nodes, links) {
    const exportData = {
      nodes: nodes.map(n => ({
        name: n.name,
        group: n.group ?? "normal"
      })),
      links: links.map(l => ({
        source: typeof l.source === "object" ? l.source.name : l.source,
        target: typeof l.target === "object" ? l.target.name : l.target,
        label: l.label ?? ""
      }))
    };
    const jsonString = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonString], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "dfa.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function exportToTikZ(nodes, links) {
    const scale = 0.15;
    const link = `% ${window.location.origin}${window.location.pathname}?dfa=${encodeDFAForURL(nodes, links)}`
    const prelude = "% \\usetikzlibrary{automata, positioning}\n" + link + "\n";
    const tikzHeader = "\\begin{center}\n\\begin{tikzpicture}[shorten >=1pt,auto,node distance=2cm,on grid]\n";
    const tikzFooter = "\\end{tikzpicture}\n\\end{center}";
    const lines = [];
    const sanitize = name => name.replace(/[^a-zA-Z0-9_]/g, '');


    nodes.forEach(node => {
      const x = (node.x * scale).toFixed(2);
      const y = (node.y * scale).toFixed(2);
      const pos = `(${x},${-y})`;
      const opts = ["state"];
      if (node.group && node.group.includes("start")) opts.push("initial");
      if (node.group && node.group.includes("accept")) opts.push("accepting");
      lines.push(`\t\\node[${opts.join(", ")}] (${sanitize(node.name)}) at ${pos} {\$${node.name}\$};`);
    });

    const grouped = {};
    links.forEach(l => {
      const src = typeof l.source === "object" ? l.source : nodes.find(n => n.name === l.source);
      const tgt = typeof l.target === "object" ? l.target : nodes.find(n => n.name === l.target);
      if (!src || !tgt) return;
      const key = `${src.name}->${tgt.name}`;
      if (!grouped[key]) grouped[key] = [];
      grouped[key].push(l.label || '');
    });

    lines.push("");
    lines.push("\t\\path[->]");
    Object.entries(grouped).forEach(([key, labels]) => {
      const [srcName, tgtName] = key.split("->");
      const src = nodes.find(n => n.name === srcName);
      const tgt = nodes.find(n => n.name === tgtName);
      const label = labels.join(", ");
      if (!src || !tgt) return;
      if (src === tgt)
        lines.push(`\t(${sanitize(src.name)}) edge [loop above] node {\$${label}\$} ()`);
      else
        lines.push(`\t(${sanitize(src.name)}) edge node {\$${label}\$} (${sanitize(tgt.name)})`);
    });
    lines.push(';')

    lines.push(tikzFooter);
    return `${prelude}${tikzHeader}${lines.join("\n")}`;
  }

  // --- Overlay logic ---
  const overlay = document.getElementById("overlayPort");
  const overlayContent = document.getElementById("portContent");
  const closeOverlay = document.getElementById("closeOverlay");

  function openOverlay(content) {
    overlayContent.textContent = content;
    overlay.style.display = "flex";
    const range = document.createRange();
    const sel = window.getSelection();
    range.selectNodeContents(overlayContent);
    sel.removeAllRanges();
    sel.addRange(range);
  }

  function closePort() {
    overlay.style.display = "none";
    overlayContent.textContent = "";
  }

  closeOverlay.addEventListener("click", closePort);
  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) closePort();
  });

  document.getElementById("latexBtn").addEventListener("click", () => {
    const tikz = exportToTikZ(nodes, links);
    openOverlay(tikz);
  });

  document.getElementById("undoBtn").addEventListener("click", () => history.back());
  document.getElementById("redoBtn").addEventListener("click", () => history.forward());

  document.getElementById("urlBtn").addEventListener("click", () => {
    const encoded = encodeDFAForURL(nodes, links);
    const newURL = `${window.location.origin}${window.location.pathname}?dfa=${encoded}`;
    navigator.clipboard.writeText(newURL).then(() => {
      openOverlay(newURL);
    }, () => {
      openOverlay('Failed to copy URL to clipboard\n\n' + newURL);
    });
  });

  document.getElementById("jsonBtn").addEventListener("click", () => {
    exportToJson(nodes, links);
  });

  function loadDfaData(data) {
    nodes.length = 0;
    links.length = 0;
    if (data) {
      (data.nodes || []).forEach(n => {
        n.name_unicode = window.unicodeit.replace(n.name);
        nodes.push(n);
      });
      (data.links || []).forEach(l => links.push({
        ...l,
        source: l.source,
        target: l.target
      }));
      console.log("Loaded DFA from data.");
    }
    updateGraphVisuals();
  }
</script>

<script>
  let linkIdCounter = 0;
  let nodes = [], links = [];
  let dragSourceNode = null, interimLink = null;
  let selectedNode = null, nodeForLink = null;
  const snapInDistance = 15;
  const snapOutDistance = 40;

  function assignLinkCurvatures(gData, curvatureMinMax = 0.5) {
    const selfLoopLinks = {};
    const sameNodesLinks = {};

    gData.links.forEach(link => {
      const sId = typeof link.source === 'object' ? link.source.name : link.source;
      const tId = typeof link.target === 'object' ? link.target.name : link.target;
      link.nodePairId = sId <= tId ? `${sId}_${tId}` : `${tId}_${sId}`;
      const map = sId === tId ? selfLoopLinks : sameNodesLinks;
      if (!map[link.nodePairId]) map[link.nodePairId] = [];
      map[link.nodePairId].push(link);
    });

    Object.keys(selfLoopLinks).forEach(id => {
      const links = selfLoopLinks[id];
      const n = links.length;
      links.forEach((link, i) => {
        link.selfIndex = i;
        link.selfCount = n;
        link.curvature = n === 1 ? 1 : curvatureMinMax + i * ((1 - curvatureMinMax) / (n - 1));
      });
    });

    Object.keys(sameNodesLinks).forEach(nodePairId => {
      const links = sameNodesLinks[nodePairId];
      const n = links.length;

      if (n === 1) {
        links[0].curvature = 0;
        return;
      }

      const lastIndex = n - 1;
      const delta = (2 * curvatureMinMax) / lastIndex;
      links.forEach((link, i) => {
        link.curvature = -curvatureMinMax + i * delta;
        const lastLink = links[lastIndex];
        const sId = typeof link.source === 'object' ? link.source.name : link.source;
        const lastSId = typeof lastLink.source === 'object' ? lastLink.source.name : lastLink.source;
        if (lastSId !== sId) link.curvature *= -1;
      });
    });
  }

  let historyIndex = 0;
  let historyLength = 1;

  function updateButtonStates() {
    document.getElementById('undoBtn').disabled = historyIndex <= 0;
    document.getElementById('redoBtn').disabled = historyIndex >= historyLength - 1;
  }

  window.addEventListener("DOMContentLoaded", () => {
    const params = new URLSearchParams(window.location.search);
    const encoded = params.get("dfa");
    if (encoded) {
      const data = decodeDFAFromURL(encoded);
      loadDfaData(data);
      history.replaceState({dfa: encoded, index: 0}, '', window.location.href);
    } else {
      history.replaceState({dfa: '', index: 0}, '', window.location.pathname);
      commitChange();
    }
    updateButtonStates();
  });

  window.addEventListener('popstate', (event) => {
    historyIndex = (event.state && event.state.index) || 0;
    updateButtonStates();

    const params = new URLSearchParams(window.location.search);
    const encoded = params.get("dfa");
    const data = decodeDFAFromURL(encoded || '');
    loadDfaData(data);
  });

  let historyUpdateTimeout;
  function updateHistory() {
    clearTimeout(historyUpdateTimeout);
    const linksForHistory = links.filter(l => l !== interimLink);
    const encoded = encodeDFAForURL(nodes, linksForHistory);
    const currentUrl = new URL(window.location.href);
    const currentDfa = currentUrl.searchParams.get('dfa');
    if (encoded !== currentDfa) {
      historyIndex++;
      historyLength = historyIndex + 1;
      currentUrl.searchParams.set('dfa', encoded);
      history.pushState({dfa: encoded, index: historyIndex}, '', currentUrl.href);
      updateButtonStates();
    }
  }

  const commitChange = () => {
    updateGraphVisuals();
    clearTimeout(historyUpdateTimeout);
    historyUpdateTimeout = setTimeout(updateHistory, 300);
  }

  const updateGraphVisuals = () => {
    assignLinkCurvatures({nodes, links});
    Graph.graphData({nodes, links});
  };

  const distance = (node1, node2) => Math.hypot(node1.x - node2.x, node1.y - node2.y);

  const rename = (obj, type) => {
    let currentValue = (type === 'link') ? obj.label : obj.name;
    let value = prompt('Name this ' + type + ':', currentValue);
    if (!value) return;
    if (type === 'node') {
      if (nodes.some(n => n.name === value && n !== obj)) {
        alert('A node with this name already exists.');
        return;
      }
      obj.name = value;
      obj.name_unicode = window.unicodeit.replace(value);
    } else {
      obj.label = value;
    }
    commitChange();
  };

  const setInterimLink = (source, target) => {
    let linkId = linkIdCounter++;
    interimLink = {id: linkId, source, target, label: ''};
    links.push(interimLink);
    updateGraphVisuals();
  };

  const addLink = (source, target) => {
    if (!source || !target) return;
    let linkId = linkIdCounter++;
    links.push({id: linkId, source, target, label: ''});
    commitChange();
  };

  const removeLink = link => {
    const index = links.indexOf(link);
    if (index > -1) {
      links.splice(index, 1);
    }
  };

  const removeInterimLinkWithoutAddingIt = () => {
    if (interimLink) removeLink(interimLink);
    interimLink = null;
    updateGraphVisuals();
  };

  const removeNode = node => {
    links = links.filter(l => l.source !== node && l.target !== node);
    nodes.splice(nodes.indexOf(node), 1);
  };

  window.addEventListener('keydown', function (event) {
    if (event.metaKey && event.key === 'z') {
      event.preventDefault();
      if (event.shiftKey) {
        history.forward();
      } else {
        history.back();
      }
    } else if (event.key === 'Escape') {
      selectedNode = null;
      nodeForLink = null;
      updateGraphVisuals();
    } else if (event.key === 'a') {
      if (!selectedNode) return;
      if (selectedNode.group === 'accept') {
        selectedNode.group = 'normal';
      } else if (selectedNode.group === 'start-accept') {
        selectedNode.group = 'start';
      } else if (selectedNode.group === 'normal') {
        selectedNode.group = 'accept';
      } else if (selectedNode.group === 'start') {
        selectedNode.group = 'start-accept';
      }
      selectedNode = null;
      nodeForLink = null;
      commitChange();
    } else if (event.key === 's') {
      if (!selectedNode) return;

      const currentStartNode = nodes.find(n => n.group.includes('start'));

      if (selectedNode.group.includes('start')) {
        if (selectedNode.group.includes('accept')) {
          selectedNode.group = 'accept';
        } else {
          selectedNode.group = 'normal';
        }
      } else {
        if (currentStartNode && currentStartNode !== selectedNode) {
          alert('There can only be one start node.');
          return;
        }
        if (selectedNode.group.includes('accept')) {
          selectedNode.group = 'start-accept';
        } else {
          selectedNode.group = 'start';
        }
      }
      selectedNode = null;
      nodeForLink = null;
      commitChange();
    }
  });

  function getQuadraticBezierPoint(p0, p1, p2, t) {
    const mt = 1 - t;
    return {
      x: mt * mt * p0.x + 2 * mt * t * p1.x + t * t * p2.x,
      y: mt * mt * p0.y + 2 * mt * t * p1.y + t * t * p2.y,
    };
  }

  function getControlPoint(source, target, curvature, lineLength) {
    const midX = (source.x + target.x) / 2;
    const midY = (source.y + target.y) / 2;

    const dx = target.x - source.x;
    const dy = target.y - source.y;

    const perpDx = -dy;
    const perpDy = dx;

    const length = Math.sqrt(perpDx * perpDx + perpDy * perpDy);
    const normalizedPerpDx = perpDx / length;
    const normalizedPerpDy = perpDy / length;

    const controlPointX = midX + normalizedPerpDx * curvature * lineLength * 0.5;
    const controlPointY = midY + normalizedPerpDy * curvature * lineLength * 0.5;

    return {x: controlPointX, y: controlPointY};
  }

  const instructionsToolbar = document.getElementById('instructionsToolbar');
  let toolbarHidden = false;

  window.addEventListener('mousemove', (event) => {
    if (toolbarHidden && event.clientY < 80) {
      instructionsToolbar.classList.remove('hidden');
      toolbarHidden = false;
    } else if (!toolbarHidden && event.clientY > 250) {
      instructionsToolbar.classList.add('hidden');
      toolbarHidden = true;
    }
  });

  const Graph = new ForceGraph(document.getElementById('graph'))
    .nodeId('name')
    .nodeLabel(node => {
      let labelSuffix = '';
      if (node.group && node.group.includes('start') && node.group.includes('accept')) {
        labelSuffix = ' (start, accept)';
      } else if (node.group && node.group.includes('start')) {
        labelSuffix = ' (start)';
      } else if (node.group && node.group.includes('accept')) {
        labelSuffix = ' (accept)';
      }
      return `${node.name_unicode}${labelSuffix}`;
    })
    .linkCurvature('curvature')
    .linkDirectionalArrowLength(6)
    .linkDirectionalArrowRelPos(1)
    .onNodeDrag(dragNode => {
      dragSourceNode = dragNode;
      for (let node of nodes) {
        if (dragNode === node) continue;
        if (!interimLink && distance(dragNode, node) < snapInDistance) setInterimLink(dragSourceNode, node);
        if (interimLink && node !== interimLink.target && distance(dragNode, node) < snapInDistance) {
          if (interimLink) removeLink(interimLink);
          setInterimLink(dragSourceNode, node);
        }
      }
      if (interimLink && distance(dragNode, interimLink.target) > snapOutDistance)
        removeInterimLinkWithoutAddingIt();
    })
    .onNodeDragEnd(() => {
      dragSourceNode = null;
      if (interimLink) {
        interimLink = null;
      }
      commitChange();
    })
    .nodeColor(node => {
      if (node === selectedNode) return '#ebcb8b';
      if (node.group && node.group.includes('start') && node.group.includes('accept')) return '#b48ead';
      if (node.group && node.group.includes('start')) return '#8fbcbb';
      if (node.group && node.group.includes('accept')) return '#88c0d0';
      if (node === dragSourceNode || (interimLink && (node === interimLink.source || node === interimLink.target))) return '#ebcb8b';
      return '#81a1c1';
    })
    .linkColor(link => link === interimLink ? '#ebcb8b' : '#81a1c1')
    .linkLineDash(link => link === interimLink ? [2, 2] : [])
    .onNodeClick((node, event) => {
      if (event.shiftKey) {
        removeNode(node);
        commitChange();
      } else rename(node, 'node');
    })
    .onNodeRightClick(node => {
      if (nodeForLink) {
        addLink(nodeForLink, node);
        selectedNode = null;
        nodeForLink = null;
      } else {
        if (selectedNode === node) {
          selectedNode = null;
          nodeForLink = null;
        } else {
          selectedNode = node;
          nodeForLink = node;
        }
      }
      updateGraphVisuals();
    })
    .onLinkClick((link, event) => {
      if (event.shiftKey) {
        removeLink(link)
        commitChange();
      }
      else {
        rename(link, 'link')
      }
    })
    .onLinkRightClick(link => { })
    .onBackgroundClick(event => {
      selectedNode = null;
      nodeForLink = null;
      let coords = Graph.screen2GraphCoords(event.layerX, event.layerY);
      let i = nodes.length;
      let name = 'q_' + i;
      while (nodes.some(n => n.name === name)) {
        i++;
        name = 'q_' + i;
      }
      const name_unicode = window.unicodeit.replace(name);
      nodes.push({x: coords.x, y: coords.y, name: name, name_unicode: name_unicode});
      commitChange();
    })
    .linkCanvasObjectMode(() => 'after')
    .linkCanvasObject((link, ctx, globalScale) => {
      const MAX_FONT_SIZE = 18;
      const LABEL_NODE_MARGIN = Graph.nodeRelSize() * 1.5;
      const start = link.source;
      const end = link.target;
      if (typeof start !== 'object' || typeof end !== 'object') return;

      let textPos, textAngle;
      const relLink = {x: end.x - start.x, y: end.y - start.y};
      const lineLength = Math.hypot(relLink.x, relLink.y);
      const isSelfLoop = lineLength < 1e-6;

      const curvature = link.curvature || 0;

      if (isSelfLoop) {
        const NODE_RADIUS = Graph.nodeRelSize();
        const SELF_LOOP_BASE_RADIUS = NODE_RADIUS * 2.5;
        const SELF_LOOP_ANGLE_OFFSET = -Math.PI / 2;
        const idx = link.selfIndex ?? 0;
        const count = link.selfCount ?? 1;
        const spread = Math.PI / 4;
        const theta = SELF_LOOP_ANGLE_OFFSET + (idx - (count - 1) / 2) * (spread / Math.max(1, count - 1));
        const loopRadius = SELF_LOOP_BASE_RADIUS * (0.6 + 0.8 * curvature);
        textPos = {
          x: start.x + Math.cos(theta) * (NODE_RADIUS + loopRadius),
          y: start.y + Math.sin(theta) * (NODE_RADIUS + loopRadius)
        };
        textAngle = theta + Math.PI / 2;
        if (textAngle > Math.PI / 2) textAngle = -(Math.PI - textAngle);
        if (textAngle < -Math.PI / 2) textAngle = -(-Math.PI - textAngle);
      } else if (curvature !== 0) {
        // Curved link
        const controlPoint = getControlPoint(start, end, - 1.5 * curvature, lineLength);
        textPos = getQuadraticBezierPoint(start, controlPoint, end, 0.5);

        // Text rotation
        const tangentX = ((controlPoint.x - start.x) + (end.x - controlPoint.x));
        const tangentY = ((controlPoint.y - start.y) + (end.y - controlPoint.y));
        textAngle = Math.atan2(tangentY, tangentX) / 2;

      } else {
        // Straight link
        textPos = {
          x: start.x + (end.x - start.x) / 2,
          y: start.y + (end.y - start.y) / 2
        };
        textAngle = Math.atan2(relLink.y, relLink.x);
        if (textAngle > Math.PI / 2) textAngle = -(Math.PI - textAngle);
        if (textAngle < -Math.PI / 2) textAngle = -(-Math.PI - textAngle);
      }

      label = unicodeit.replace(link.label || "");
      const fontSize = MAX_FONT_SIZE / globalScale;
      ctx.font = `${fontSize}px Sans-Serif`;
      const textWidth = ctx.measureText(label).width;
      const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2);
      ctx.save();
      ctx.translate(textPos.x, textPos.y);
      ctx.rotate(textAngle);
      ctx.fillStyle = '#eceff4a0';
      ctx.fillRect(-bckgDimensions[0] / 2, -bckgDimensions[1] / 2, ...bckgDimensions);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#5e81aca0';
      ctx.fillText(label, 0, 0);
      ctx.restore();
    });

  commitChange();
</script>
